// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";

import "../src/MemoryMappings.sol";

import "lib/solady/src/utils/LibSort.sol";

contract MemoryMapsTest is Test {
    function setUp() public {}

    uint256 public bound = 100;

    function test_benchmark_words() public {
        MemoryMappings.MemoryMapping memory mm = MemoryMappings.newMemoryMapping({sorted: true, overwrite: false});

        uint256 gasTotal;
        uint256 gasBefore;
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            bytes32 value = keccak256(abi.encode(key));
            gasBefore = gasleft();
            MemoryMappings.add(mm, key, value);
            gasTotal += gasBefore - gasleft();
            //console.log(uint256(key), uint256(value));
        }
        console.log("%d gas total", gasTotal);
        console.log("%d gas per add", gasTotal / bound);

        gasBefore = gasleft();
        (uint256[] memory arrA, uint256[] memory arrB) = MemoryMappings.dumpUint256s(mm);
        gasTotal = gasBefore - gasleft();
        console.log("%d dump gas", gasTotal);
        console.log("%d dump per elt", gasTotal / bound);

        /*
        console.log("--");
        for (uint256 i; i < bound; ++i) {
            console.log(uint256(arrA[i]), uint256(arrB[i]));
        }
        console.log("--");
       */

        for (uint256 i; i < bound; ++i) {
            uint256 key = arrA[i];
            bytes32 value = keccak256(abi.encode(key));
            /*
            console.log(uint256(value));
            console.log(uint256(arrB[i]));
            console.log("--");
            */
            assertEq(bytes32(arrB[i]), value);
        }

        bool ok;
        bytes memory value;
        gasTotal = 0;
        uint256 max;
        uint256 min = type(uint256).max;
        uint256 gasUsed;
        //console.log("----");
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            bytes32 expectedValue = keccak256(abi.encode(key));
            gasBefore = gasleft();
            (ok, value) = MemoryMappings.get(mm, key);
            gasUsed = gasBefore - gasleft();
            //console.log(uint256(key), uint256(expectedValue));
            //console.log(uint256(key), abi.decode(value, (uint256)));
            //console.log("%d gasUsed", gasUsed);
            gasTotal += gasUsed;
            //console.log("debug 0");
            assertEq(ok, true);
            //console.log("debug 1");
            if (gasUsed > max) max = gasUsed;
            if (gasUsed < min) min = gasUsed;
            assertEq(abi.decode(value, (bytes32)), expectedValue);
        }
        //console.log("----");
        console.log("%d get gas total", gasTotal);
        console.log("%d get gas avg", gasTotal / bound);
        console.log("%d gas max", max);
        console.log("%d gas min", min);

        bytes32[] memory keys = new bytes32[](bound);
        bytes32[] memory values = new bytes32[](bound);
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            keys[i] = key;
            bytes32 value = keccak256(abi.encode(key));
            values[i] = value;
        }
        // worst case linear search
        bytes32 searchTerm = keccak256(abi.encode(bound - 1));
        gasBefore = gasleft();
        bytes32 found;
        for (uint256 i; i < bound; ++i) {
            if (keys[i] == searchTerm) {
                found = values[i];
            }
        }
        console.log("%d ignorant linear search gas", gasBefore - gasleft());
    }

    function test_benchmark_bytes() public {
        MemoryMappings.MemoryMapping memory mm = MemoryMappings.newMemoryMapping({sorted: true, overwrite: false});

        uint256 gasTotal;
        uint256 gasBefore;
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            bytes memory value = bytes.concat(bytes("hello_cat??"), abi.encode(keccak256(abi.encode(i))));
            gasBefore = gasleft();
            MemoryMappings.add(mm, key, value);
            gasTotal += gasBefore - gasleft();
            //console.log(uint256(key), uint256(value));
        }
        console.log("%d gas total", gasTotal);
        console.log("%d gas per add", gasTotal / bound);

        gasBefore = gasleft();
        (uint256[] memory arrA, bytes[] memory arrB) = MemoryMappings.dumpBytes(mm);
        gasTotal = gasBefore - gasleft();
        console.log("%d dumpBytes gas", gasTotal);
        console.log("%d dumpBytes per elt", gasTotal / bound);

        for (uint256 i; i < bound; ++i) {
            uint256 key = arrA[i];
            (bool ok, bytes memory expectedValue) = MemoryMappings.get(mm, bytes32(key));
            assertEq(keccak256(arrB[i]), keccak256(expectedValue));
        }

        bool ok;
        bytes memory value;
        gasTotal = 0;
        uint256 max;
        uint256 min = type(uint256).max;
        uint256 gasUsed;
        console.log("----");
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            bytes memory expectedValue = bytes.concat(bytes("hello_cat??"), abi.encode(keccak256(abi.encode(i))));
            gasBefore = gasleft();
            (ok, value) = MemoryMappings.get(mm, key);
            gasUsed = gasBefore - gasleft();
            //console.log("%d gasUsed", gasUsed);
            gasTotal += gasUsed;
            assertEq(ok, true);
            if (gasUsed > max) max = gasUsed;
            if (gasUsed < min) min = gasUsed;
            assertEq(keccak256(value), keccak256(expectedValue));
        }
        console.log("----");
        console.log("%d get gas total", gasTotal);
        console.log("%d get gas avg", gasTotal / bound);
        console.log("%d gas max", max);
        console.log("%d gas min", min);

        bytes32[] memory keys = new bytes32[](bound);
        bytes[] memory values = new bytes[](bound);
        for (uint256 i; i < bound; ++i) {
            bytes32 key = keccak256(abi.encode(i));
            keys[i] = key;
            bytes memory value = bytes.concat(bytes("hello_"), abi.encode(keccak256("cat??")), abi.encode(i));
            values[i] = value;
        }
        // worst case linear search
        bytes32 searchTerm = keccak256(abi.encode(bound - 1));
        gasBefore = gasleft();
        bytes memory found;
        for (uint256 i; i < bound; ++i) {
            if (keys[i] == searchTerm) {
                found = values[i];
            }
        }
        console.log("%d ignorant linear search gas", gasBefore - gasleft());
    }

    function test_benchmark_bytes_bytes() public {
        MemoryMappings.MemoryMapping memory mm = MemoryMappings.newMemoryMapping({sorted: false, overwrite: false});

        uint256 gasTotal;
        uint256 gasBefore;
        bytes memory key;
        bytes memory value;
        for (uint256 i; i < bound; ++i) {
            key = bytes.concat(bytes("hello_catKEY??"), abi.encode(keccak256(abi.encode(i))));
            value = bytes.concat(bytes("hello_cat??"), abi.encode(keccak256(abi.encode(i))));
            gasBefore = gasleft();
            MemoryMappings.add(mm, key, value);
            gasTotal += gasBefore - gasleft();
            //console.log(uint256(key), uint256(value));
        }
        console.log("%d gas total", gasTotal);
        console.log("%d gas per add", gasTotal / bound);

        gasBefore = gasleft();
        (bytes[] memory arrA, bytes[] memory arrB) = MemoryMappings.dumpBothBytes(mm);
        gasTotal = gasBefore - gasleft();
        console.log("%d dumpBothBytes gas", gasTotal);
        console.log("%d dumpBothBytes per elt", gasTotal / bound);

        for (uint256 i; i < bound; ++i) {
            bytes memory key = arrA[i];
            (bool ok, bytes memory expectedValue) = MemoryMappings.get(mm, key);
            assertEq(keccak256(arrB[i]), keccak256(expectedValue));
        }

        bool ok;
        gasTotal = 0;
        uint256 max;
        uint256 min = type(uint256).max;
        uint256 gasUsed;
        console.log("----");
        for (uint256 i; i < bound; ++i) {
            bytes memory key = bytes.concat(bytes("hello_catKEY??"), abi.encode(keccak256(abi.encode(i))));
            bytes memory expectedValue = bytes.concat(bytes("hello_cat??"), abi.encode(keccak256(abi.encode(i))));
            gasBefore = gasleft();
            (ok, value) = MemoryMappings.get(mm, key);
            gasUsed = gasBefore - gasleft();
            //console.log("%d gasUsed", gasUsed);
            gasTotal += gasUsed;
            assertEq(ok, true);
            if (gasUsed > max) max = gasUsed;
            if (gasUsed < min) min = gasUsed;
            assertEq(keccak256(value), keccak256(expectedValue));
        }
        console.log("----");
        console.log("%d get gas total", gasTotal);
        console.log("%d get gas avg", gasTotal / bound);
        console.log("%d gas max", max);
        console.log("%d gas min", min);

        bytes[] memory keys = new bytes[](bound);
        bytes[] memory values = new bytes[](bound);
        for (uint256 i; i < bound; ++i) {
            bytes memory key = bytes.concat(bytes("hello_catKEY??"), abi.encode(keccak256(abi.encode(i))));
            keys[i] = key;
            bytes memory value = bytes.concat(bytes("hello_"), abi.encode(keccak256("cat??")), abi.encode(i));
            values[i] = value;
        }
        // worst case linear search
        bytes memory searchTerm = bytes.concat(bytes("hello_catKEY??"), abi.encode(keccak256(abi.encode(bound - 1))));
        gasBefore = gasleft();
        bytes memory found;
        for (uint256 i; i < bound; ++i) {
            if (keccak256(keys[i]) == keccak256(searchTerm)) {
                found = values[i];
            }
        }
        console.log("%d ignorant linear search gas", gasBefore - gasleft());
    }

    function hasDuplicate(uint256[] memory arr) public pure returns(bool tf) {
        MemoryMappings.MemoryMapping memory mm = MemoryMappings.newMemoryMapping({sorted: false, overwrite: true});
        uint256 a;
        for (uint256 i; i < arr.length; ++i) {
            a = arr[i]; 
            (tf,) = MemoryMappings.get(mm, bytes32(a));
            if (tf) break;
            MemoryMappings.add(mm, bytes32(a), bytes32(0));
        }
        return tf;
    }

    function hasDuplicate_2(uint256[] memory arr) public pure returns(bool tf) {
        MemoryMappings.MemoryMapping memory mm = MemoryMappings.newMemoryMapping({sorted: false, overwrite: true});
        uint256 a;
        for (uint256 i; i < arr.length; ++i) {
            a = arr[i]; 
            MemoryMappings.add(mm, bytes32(a), bytes32(0));
        }
        return mm.totalKeys != arr.length;
    }

    function test_compare_hasDuplicate() public {
        uint256 bound = 100;
        uint256[] memory arr = new uint256[](bound); 
        for (uint256 i; i < bound; ++i) {
            arr[i] = uint256(keccak256(abi.encode(i))) % bound; 
        }

        uint256 gasBefore = gasleft();
        bool tf = LibSort.hasDuplicate(arr);
        console.log("%d solady hasDup gas", gasBefore-gasleft());

        if (tf) {
            console.log("has duplicate");
        } else {
            console.log("no duplicate");
        }

        gasBefore = gasleft();
        bool _tf = hasDuplicate(arr);
        console.log("%d MemoryMappings hasDup gas", gasBefore-gasleft());

        if (_tf) {
            console.log("has duplicate");
        } else {
            console.log("no duplicate");
        }
        console.log("Not even close to as good as Solady's 'hasDuplicate'");

        gasBefore = gasleft();
        bool __tf = hasDuplicate_2(arr);
        console.log("%d MemoryMappings hasDup2 gas", gasBefore-gasleft());

        if (__tf) {
            console.log("has duplicate");
        } else {
            console.log("no duplicate");
        }
        console.log("Not even close to as good as Solady's 'hasDuplicate'");
    }
}
